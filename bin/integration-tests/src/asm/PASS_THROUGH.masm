use.miden::active_note
use.miden::output_note
use.miden::tx

#Â CONSTANTS
# =================================================================================================

#Â ERRORS
# =================================================================================================

# PASS_THROUGH script expects exactly 12 note inputs
const.ERR_PASS_THROUGH_WRONG_NUMBER_OF_INPUTS="wrong number of inputs"

# PASS_THROUGH script requires exactly 1 note asset
const.ERR_PASS_THROUGH_WRONG_NUMBER_OF_ASSETS="wrong number of assets"

#! PASS_THROUGH script:
#! Creates a note consumable by pass-through, containing the same asset.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Note inputs are assumed to be as follows:
#! - ASSET
#! - RECIPIENT
#! - [hint, note_type, aux, tag]
begin
    # drop note arguments
    dropw

    # store note inputs into memory starting at address 0
    # TODO use active_note once changes propagate to client repo
    push.0 exec.active_note::get_inputs
    # => [num_inputs, inputs_ptr]

    # make sure the number of inputs is 12
    eq.12 assert.err=ERR_PASS_THROUGH_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]

    # load ASSET
    mem_loadw_be
    # => [ASSET]

    padw mem_loadw_be.4
    # => [RECIPIENT, ASSET]

    padw mem_loadw_be.8
    # => [tag, aux, note_type, execution_hint, RECIPIENT, ASSET]
    debug.stack

    # create a note using inputs
    exec.output_note::create
    debug.stack.5
    # => [note_idx, ASSET]

    debug.stack

    movdn.4
    # => [ASSET, note_idx, pad(11)]
    # add asset to the note
    exec.output_note::add_asset
    # => [ASSET, note_idx]

    # clean stack
    dropw dropw dropw dropw
    # => []
end

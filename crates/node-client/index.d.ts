/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Account {
  /** Returns the account identifier. */
  id(): AccountId;
  /** Returns the commitment to the account header, storage, and code. */
  commitment(): Word;
  /** Returns the account nonce. */
  nonce(): Felt;
  /** Returns the asset vault for this account. */
  vault(): AssetVault;
  /** Returns true if the account is a faucet. */
  isFaucet(): boolean;
  /** Returns true if the account is a regular account. */
  isRegularAccount(): boolean;
  /** Returns true if the account can update its code. */
  isUpdatable(): boolean;
  /** Returns true if the account uses public storage. */
  isPublic(): boolean;
  /** Returns true if the account storage is private. */
  isPrivate(): boolean;
  /** Returns true if this is a network-owned account. */
  isNetwork(): boolean;
  /** Returns true if the account has not yet been committed to the chain. */
  isNew(): boolean;
  /** Serializes the account into bytes. */
  serialize(): Buffer;
  /** Restores an account from its serialized bytes. */
  static deserialize(bytes: Buffer): Account;
  /** Returns the public key commitments derived from the account's auth scheme. */
  getPublicKeyCommitments(): Array<Word>;
}

export declare class AccountHeader {
  /** Returns the full account commitment. */
  commitment(): Word;
  /** Returns the account ID. */
  id(): AccountId;
  /** Returns the current nonce. */
  nonce(): Felt;
  /** Returns the vault commitment. */
  vaultCommitment(): Word;
  /** Returns the storage commitment. */
  storageCommitment(): Word;
  /** Returns the code commitment. */
  codeCommitment(): Word;
}

export declare class AccountId {
  /** Builds an account ID from its hex string representation. */
  static fromHex(hex: string): AccountId;
  /** Returns true if the ID refers to a faucet. */
  isFaucet(): boolean;
  /** Returns true if the ID refers to a regular account. */
  isRegularAccount(): boolean;
  /** Returns true if the account uses public storage. */
  isPublic(): boolean;
  /** Returns true if the account uses private storage. */
  isPrivate(): boolean;
  /** Returns true if the ID is reserved for network accounts. */
  isNetwork(): boolean;
  /** Returns the canonical hex representation of the account ID. */
  toString(): string;
  /** Returns the prefix field element. */
  prefix(): Felt;
  /** Returns the suffix field element. */
  suffix(): Felt;
  /** Converts to bech32 representation with a given network. */
  toBech32(network: string): string;
  /** Given a bech32 encoded string, return the matching Account ID for it. */
  static fromBech32(bech32: string): AccountId;
}

export declare class Address {
  /** Deserializes an Address from bytes. */
  static deserialize(bytes: Buffer): Address;
  /** Builds an address from an account ID and optional interface. */
  static fromAccountId(
    accountId: AccountId,
    interface?: string | undefined | null
  ): Address;
  /** Builds an address from a bech32-encoded string. */
  static fromBech32(bech32: string): Address;
  /** Returns the account ID embedded in the address. */
  accountId(): AccountId;
}

export declare class AssetVault {
  /** Returns the balance for the given fungible faucet, or zero if absent. */
  getBalance(faucetId: AccountId): bigint;
}

export declare class AuthSecretKey {
  /** Generates a new RPO Falcon 512 key pair, optionally from a seed. */
  static rpoFalconWithRng(seed?: Buffer | undefined | null): AuthSecretKey;
  /** Generates a new ECDSA k256 Keccak key pair, optionally from a seed. */
  static ecdsaWithRng(seed?: Buffer | undefined | null): AuthSecretKey;
  /** Returns the public key commitment as a Word. */
  getPublicKeyAsWord(): Word;
  /** Serializes the key into bytes. */
  serialize(): Buffer;
  /** Deserializes a key from bytes. */
  static deserialize(bytes: Buffer): AuthSecretKey;
}

export declare class Felt {
  constructor(value: bigint);
  asInt(): bigint;
  toString(): string;
}

export declare class InputNoteRecord {
  /** Returns the note ID. */
  id(): NoteId;
  /** Returns the consumer transaction ID if the note has been consumed. */
  consumerTransactionId(): string | null;
  /** Returns the nullifier for this note. */
  nullifier(): string;
  /** Returns true if the record contains authentication data (proof). */
  isAuthenticated(): boolean;
  /** Returns true if the note has already been consumed. */
  isConsumed(): boolean;
  /** Returns true if the note is currently being processed. */
  isProcessing(): boolean;
  /** Converts the record into a Note. */
  toNote(): Note;
}

export declare class NodeClient {
  /**
   * Creates a new NodeClient connected to a Miden node.
   *
   * # Arguments
   * * `rpc_url` - URL of the Miden node RPC endpoint (e.g. "https://rpc.testnet.miden.io:443").
   *   If not provided, defaults to the testnet endpoint.
   * * `db_path` - Path to the SQLite database file for client state.
   * * `keys_dir` - Path to the directory where keys are stored.
   * * `seed` - Optional 32-byte seed for deterministic key generation.
   */
  static createClient(
    rpcUrl: string | undefined | null,
    dbPath: string,
    keysDir: string,
    seed?: Buffer | undefined | null
  ): NodeClient;
  /** Returns all account headers tracked by this client. */
  getAccounts(): Array<AccountHeader>;
  /** Returns an account by its ID, or None if not found. */
  getAccount(accountId: AccountId): Account | null;
  /** Returns all public key commitments associated with the given account ID. */
  getPublicKeyCommitmentsOfAccount(accountId: AccountId): Array<Word>;
  /** Retrieves an auth secret key from the keystore given a public key commitment. */
  getAccountAuthByPubKeyCommitment(pubKeyCommitment: Word): NodeAuthSecretKey;
  /** Creates a new wallet account. */
  newWallet(
    storageMode: AccountStorageMode,
    mutable: boolean,
    authScheme: AuthScheme,
    initSeed?: Buffer | undefined | null
  ): Account;
  /** Creates a new fungible faucet account. */
  newFaucet(
    storageMode: AccountStorageMode,
    nonFungible: boolean,
    tokenSymbol: string,
    decimals: number,
    maxSupply: bigint,
    authScheme: AuthScheme
  ): Account;
  /** Adds a previously-created account to the client. */
  newAccount(account: Account, overwrite: boolean): void;
  /** Stores a secret key in the keystore for a given account. */
  addAccountSecretKey(accountId: AccountId, secretKey: NodeAuthSecretKey): void;
  /** Inserts an address for a given account. */
  insertAccountAddress(accountId: AccountId, address: Address): void;
  /** Removes an address for a given account. */
  removeAccountAddress(accountId: AccountId, address: Address): void;
  /** Synchronizes the client state with the Miden network. */
  syncState(): SyncSummary;
  /** Returns the current sync height. */
  getSyncHeight(): number;
  /** Adds a note tag to track. */
  addTag(tag: string): void;
  /** Removes a note tag. */
  removeTag(tag: string): void;
  /** Lists all tracked note tags. */
  listTags(): Array<string>;
  /** Gets a setting value by key. */
  getSetting(key: string): Buffer | null;
  /** Sets a setting key-value pair. */
  setSetting(key: string, value: Buffer): void;
  /** Removes a setting by key. */
  removeSetting(key: string): void;
  /** Lists all setting keys. */
  listSettingKeys(): Array<string>;
  /** Returns input notes matching the given filter. */
  getInputNotes(filter: NoteFilterType): Array<InputNoteRecord>;
  /** Returns output notes matching the given filter. */
  getOutputNotes(filter: NoteFilterType): Array<OutputNoteRecord>;
  /** Returns consumable notes, optionally filtered by account. */
  getConsumableNotes(
    accountId?: AccountId | undefined | null
  ): Array<InputNoteRecord>;
  /** Returns a single input note by ID, or None if not found. */
  getInputNote(noteId: NoteId): InputNoteRecord | null;
  /** Returns a single output note by ID, or None if not found. */
  getOutputNote(noteId: NoteId): OutputNoteRecord | null;
  /** Creates a mint transaction request for a fungible asset. */
  newMintTransactionRequest(
    targetAccountId: AccountId,
    faucetId: AccountId,
    noteType: string,
    amount: bigint
  ): Buffer;
  /** Creates a send (pay-to-id) transaction request. */
  newSendTransactionRequest(
    senderAccountId: AccountId,
    targetAccountId: AccountId,
    faucetId: AccountId,
    noteType: string,
    amount: bigint,
    recallHeight?: number | undefined | null
  ): Buffer;
  /** Creates a swap transaction request. */
  newSwapTransactionRequest(
    senderAccountId: AccountId,
    offeredAssetFaucetId: AccountId,
    offeredAssetAmount: bigint,
    requestedAssetFaucetId: AccountId,
    requestedAssetAmount: bigint,
    noteType: string,
    paybackNoteType: string
  ): Buffer;
  /** Creates a consume transaction request from a list of notes. */
  newConsumeTransactionRequest(listOfNotes: Array<Note>): Buffer;
  /** Executes, proves, submits, and applies a transaction in one step. */
  submitNewTransaction(
    accountId: AccountId,
    transactionRequestBytes: Buffer
  ): TransactionId;
  /** Imports an account file (account + keys). */
  importAccountFile(accountBytes: Buffer, keyBytes: Array<Buffer>): string;
  /** Imports a note file. */
  importNoteFile(noteFileBytes: Buffer): NoteId;
  /** Imports a public account by ID from the network. */
  importAccountById(accountId: AccountId): void;
  /** Returns transactions matching the given filter. */
  getTransactions(filter: string): Array<TransactionId>;
  /** Ensures the genesis block has been fetched and stored. */
  ensureGenesisInPlace(): void;
}

export declare class Note {
  /** Returns the note ID. */
  id(): NoteId;
  /** Serializes the note into bytes. */
  serialize(): Buffer;
  /** Restores a note from its serialized bytes. */
  static deserialize(bytes: Buffer): Note;
}

export declare class NoteId {
  /** Creates a NoteId from a hex string. */
  static fromHex(hex: string): NoteId;
  /** Returns the hex representation. */
  toString(): string;
}

export declare class OutputNoteRecord {
  /** Returns the note ID. */
  id(): NoteId;
  /** Returns the recipient digest committed for the note. */
  recipientDigest(): Word;
  /** Returns the expected block height for the note. */
  expectedHeight(): number;
  /** Returns the nullifier when the recipient is known. */
  nullifier(): string | null;
  /** Returns true if the note has been consumed on chain. */
  isConsumed(): boolean;
  /** Returns true if the note is committed on chain. */
  isCommitted(): boolean;
}

export declare class SyncSummary {
  /** Returns the block height the summary is based on. */
  blockNum(): number;
  /** Returns IDs of notes committed in this sync window. */
  committedNotes(): Array<NoteId>;
  /** Returns IDs of notes that were consumed. */
  consumedNotes(): Array<NoteId>;
  /** Returns accounts that were updated. */
  updatedAccounts(): Array<AccountId>;
  /** Returns transactions that were committed. */
  committedTransactions(): Array<TransactionId>;
}

export declare class TransactionId {
  /** Returns the hex representation. */
  toHex(): string;
  /** Returns the underlying word representation. */
  inner(): Word;
}

export declare class Word {
  /** Creates a word from four u64 values. */
  constructor(values: Array<bigint>);
  /** Creates a Word from a hex string. */
  static fromHex(hex: string): Word;
  /** Returns the hex representation of the word. */
  toHex(): string;
  /** Serializes the word into bytes. */
  serialize(): Buffer;
  /** Deserializes a word from bytes. */
  static deserialize(bytes: Buffer): Word;
  /** Returns the word as an array of u64 values. */
  toU64s(): Array<bigint>;
  /** Returns the word as an array of field elements. */
  toFelts(): Array<Felt>;
}

export declare const enum AccountStorageMode {
  Private = "Private",
  Public = "Public",
  Network = "Network",
}

export declare const enum AuthScheme {
  RpoFalcon512 = "RpoFalcon512",
  EcdsaK256Keccak = "EcdsaK256Keccak",
}

export declare const enum NoteFilterType {
  All = "All",
  Consumed = "Consumed",
  Committed = "Committed",
  Expected = "Expected",
  Processing = "Processing",
  Unverified = "Unverified",
}

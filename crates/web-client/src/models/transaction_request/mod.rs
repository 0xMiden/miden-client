use miden_client::note::Note as NativeNote;
use miden_client::transaction::TransactionRequest as NativeTransactionRequest;
use crate::prelude::*;

#[cfg(feature = "napi")]
use miden_client::{Deserializable, Serializable};
#[cfg(feature = "napi")]
use napi::bindgen_prelude::*;
#[cfg(feature = "wasm")]
use wasm_bindgen_futures::js_sys::Uint8Array;
#[cfg(feature = "wasm")]
use crate::utils::{deserialize_from_uint8array, serialize_to_uint8array};

use crate::models::note::Note;
use crate::models::word::Word;

pub mod note_and_args;
pub mod note_details_and_tag;
pub mod note_id_and_args;
pub mod transaction_request_builder;

use note_details_and_tag::NoteDetailsAndTag;

/// Specifies a transaction request that can be executed by an account.
///
/// A request contains information about input notes to be consumed by the transaction (if any),
/// description of the transaction script to be executed (if any), and a set of notes expected to be
/// generated by the transaction or by consuming notes generated by the transaction.
#[bindings]
#[derive(Clone)]
pub struct TransactionRequest(NativeTransactionRequest);

#[bindings]
impl TransactionRequest {
    /// Returns the transaction script argument if present.
    pub fn script_arg(&self) -> Option<Word> {
        self.0.script_arg().map(Word::from)
    }

    /// Returns the authentication argument if present.
    pub fn auth_arg(&self) -> Option<Word> {
        self.0.auth_arg().map(Word::from)
    }
}

// wasm-specific impl block
#[cfg(feature = "wasm")]
#[wasm_bindgen]
impl TransactionRequest {
    /// Serializes the transaction request into bytes.
    pub fn serialize(&self) -> Uint8Array {
        serialize_to_uint8array(&self.0)
    }

    /// Deserializes a transaction request from bytes.
    pub fn deserialize(bytes: &Uint8Array) -> JsResult<TransactionRequest> {
        deserialize_from_uint8array::<NativeTransactionRequest>(bytes).map(TransactionRequest)
    }

    /// Returns output notes created by the sender account.
    
    pub fn expected_output_own_notes(&self) -> JsResult<Vec<Note>> {
        let native_notes: Vec<NativeNote> = self.0.expected_output_own_notes();
        let notes: Vec<Note> = native_notes.into_iter().map(Into::into).collect();
        Ok(notes)
    }

    /// Returns notes expected to be created in subsequent executions.
    
    pub fn expected_future_notes(&self) -> JsResult<Vec<NoteDetailsAndTag>> {
        self.0
            .expected_future_notes()
            .cloned()  // This converts &(T, U) to (T, U)
            .map(|(note_details, note_tag)| {
                let details: crate::models::note_details::NoteDetails = note_details.into();
                let tag: crate::models::note_tag::NoteTag = note_tag.into();
                Ok(NoteDetailsAndTag::new(&details, &tag))
            })
            .collect::<Result<Vec<NoteDetailsAndTag>, _>>()
    }
}

// napi-specific impl block
#[cfg(feature = "napi")]
impl TransactionRequest {
    /// Serializes the transaction request into bytes.
    #[napi]
    pub fn serialize(&self) -> Buffer {
        let bytes = self.0.to_bytes();
        Buffer::from(bytes)
    }

    /// Deserializes a transaction request from bytes.
    #[napi(factory)]
    pub fn deserialize(bytes: Buffer) -> JsResult<TransactionRequest> {
        NativeTransactionRequest::read_from_bytes(&bytes)
            .map(TransactionRequest)
            .map_err(|e| {
                platform::error_with_context(e, "Failed to deserialize TransactionRequest")
            })
    }

    /// Returns output notes created by the sender account.
    pub fn expected_output_own_notes(&self) -> Vec<Note> {
        let native_notes: Vec<NativeNote> = self.0.expected_output_own_notes();
        native_notes.into_iter().map(Into::into).collect()
    }

    /// Returns notes expected to be created in subsequent executions.
    pub fn expected_future_notes(&self) -> JsResult<Vec<NoteDetailsAndTag>> {
        self.0
            .expected_future_notes()
            .cloned()
            .map(|(note_details, note_tag)| {
                Ok(NoteDetailsAndTag::new_internal(
                    note_details.into(),
                    note_tag.into(),
                ))
            })
            .collect::<Result<Vec<NoteDetailsAndTag>, _>>()
    }
}

// CONVERSIONS
// ================================================================================================

impl From<TransactionRequest> for NativeTransactionRequest {
    fn from(transaction_request: TransactionRequest) -> Self {
        transaction_request.0
    }
}

impl From<&TransactionRequest> for NativeTransactionRequest {
    fn from(transaction_request: &TransactionRequest) -> Self {
        transaction_request.0.clone()
    }
}

impl From<NativeTransactionRequest> for TransactionRequest {
    fn from(transaction_request: NativeTransactionRequest) -> Self {
        TransactionRequest(transaction_request)
    }
}

impl From<&NativeTransactionRequest> for TransactionRequest {
    fn from(transaction_request: &NativeTransactionRequest) -> Self {
        TransactionRequest(transaction_request.clone())
    }
}

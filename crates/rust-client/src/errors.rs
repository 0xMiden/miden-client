use alloc::{
    string::{String, ToString},
    vec::Vec,
};

use miden_objects::{
    accounts::AccountId, crypto::merkle::MerkleError, notes::NoteId, AccountError, AssetError,
    NoteError, TransactionScriptError,
};
use miden_tx::{
    utils::{DeserializationError, HexParseError},
    TransactionExecutorError, TransactionProverError,
};
use thiserror::Error;

use crate::{
    notes::NoteScreenerError,
    rpc::RpcError,
    store::{NoteRecordError, StoreError},
    transactions::{TransactionRequestError, TransactionScriptBuilderError},
};

// CLIENT ERROR
// ================================================================================================

/// Errors generated by the client.
#[derive(Debug, Error)]
pub enum ClientError {
    #[error("account error")]
    AccountError(#[source] AccountError),
    #[error("account with id {0} is locked")]
    AccountLocked(AccountId),
    #[error("asset error")]
    AssetError(#[source] AssetError),
    #[error("data deserialization error")]
    DataDeserializationError(#[source] DeserializationError),
    #[error("note with id {0} not found on chain")]
    NoteNotFoundOnChain(NoteId),
    #[error("error parsing hex: {0}")]
    //TODO: use source in this error when possible
    HexParseError(HexParseError),
    #[error("can't import new account without seed")]
    ImportNewAccountWithoutSeed,
    #[error("error with merkle path: {0}")]
    //TODO: use source in this error when possible
    MerkleError(MerkleError),
    #[error("the transaction did not produce the expected notes corresponding to note ids")]
    MissingOutputNotes(Vec<NoteId>),
    #[error("note error")]
    NoteError(#[source] NoteError),
    #[error("note import error: {0}")]
    NoteImportError(String),
    #[error("note record error")]
    NoteRecordError(#[source] NoteRecordError),
    #[error("no consumable note for account {0}")]
    NoConsumableNoteForAccount(AccountId),
    #[error("rpc api error")]
    RpcError(#[source] RpcError),
    #[error("note screener error")]
    NoteScreenerError(#[source] NoteScreenerError),
    #[error("store error")]
    StoreError(#[source] StoreError),
    #[error("transaction executor error")]
    TransactionExecutorError(#[source] TransactionExecutorError),
    #[error("transaction prover error")]
    TransactionProvingError(#[source] TransactionProverError),
    #[error("transaction request error")]
    TransactionRequestError(#[source] TransactionRequestError),
    #[error("transaction script builder error")]
    TransactionScriptBuilderError(#[source] TransactionScriptBuilderError),
    #[error("transaction script error")]
    TransactionScriptError(#[source] TransactionScriptError),
}

// CONVERSIONS
// ================================================================================================

impl From<AccountError> for ClientError {
    fn from(err: AccountError) -> Self {
        Self::AccountError(err)
    }
}

impl From<DeserializationError> for ClientError {
    fn from(err: DeserializationError) -> Self {
        Self::DataDeserializationError(err)
    }
}

impl From<HexParseError> for ClientError {
    fn from(err: HexParseError) -> Self {
        Self::HexParseError(err)
    }
}

impl From<NoteError> for ClientError {
    fn from(err: NoteError) -> Self {
        Self::NoteError(err)
    }
}

impl From<NoteRecordError> for ClientError {
    fn from(err: NoteRecordError) -> Self {
        Self::NoteRecordError(err)
    }
}

impl From<MerkleError> for ClientError {
    fn from(err: MerkleError) -> Self {
        Self::MerkleError(err)
    }
}

impl From<RpcError> for ClientError {
    fn from(err: RpcError) -> Self {
        Self::RpcError(err)
    }
}

impl From<StoreError> for ClientError {
    fn from(err: StoreError) -> Self {
        Self::StoreError(err)
    }
}

impl From<TransactionExecutorError> for ClientError {
    fn from(err: TransactionExecutorError) -> Self {
        Self::TransactionExecutorError(err)
    }
}

impl From<TransactionProverError> for ClientError {
    fn from(err: TransactionProverError) -> Self {
        Self::TransactionProvingError(err)
    }
}

impl From<NoteScreenerError> for ClientError {
    fn from(err: NoteScreenerError) -> Self {
        Self::NoteScreenerError(err)
    }
}

impl From<TransactionRequestError> for ClientError {
    fn from(err: TransactionRequestError) -> Self {
        Self::TransactionRequestError(err)
    }
}

impl From<ClientError> for String {
    fn from(err: ClientError) -> String {
        err.to_string()
    }
}

impl From<TransactionScriptBuilderError> for ClientError {
    fn from(err: TransactionScriptBuilderError) -> Self {
        Self::TransactionScriptBuilderError(err)
    }
}

// ID PREFIX FETCH ERROR
// ================================================================================================

/// Error when Looking for a specific ID from a partial ID
#[derive(Debug, Error)]
pub enum IdPrefixFetchError {
    /// No matches were found for the ID prefix
    #[error("no matches were found with the {0}")]
    NoMatch(String),
    /// Multiple entities matched with the ID prefix
    #[error("found more than one element for the provided {0} and only one match is expected")]
    MultipleMatches(String),
}

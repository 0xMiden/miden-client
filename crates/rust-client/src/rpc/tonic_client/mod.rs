use alloc::boxed::Box;
use alloc::collections::{BTreeMap, BTreeSet};
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::error::Error;

use miden_objects::Word;
use miden_objects::account::{Account, AccountCode, AccountId};
use miden_objects::block::{AccountWitness, BlockHeader, BlockNumber, ProvenBlock};
use miden_objects::crypto::merkle::{Forest, MerklePath, MmrProof, SmtProof};
use miden_objects::note::{NoteId, NoteScript, NoteTag, Nullifier};
use miden_objects::transaction::ProvenTransaction;
use miden_objects::utils::Deserializable;
use miden_tx::utils::Serializable;
use miden_tx::utils::sync::RwLock;
use tonic::Status;
use tracing::info;

use super::domain::account::{AccountProof, AccountProofs, AccountUpdateSummary};
use super::domain::note::FetchedNote;
use super::domain::nullifier::NullifierUpdate;
use super::{
    Endpoint,
    FetchedAccount,
    NodeRpcClient,
    NodeRpcClientEndpoint,
    NoteSyncInfo,
    RpcError,
    StateSyncInfo,
};
use crate::rpc::errors::{AcceptHeaderError, GrpcError, RpcConversionError};
use crate::rpc::generated as proto;
use crate::rpc::generated::rpc_store::BlockRange;
use crate::transaction::ForeignAccount;

mod api_client;
use api_client::api_client_wrapper::ApiClient;

// TONIC RPC CLIENT
// ================================================================================================

/// Client for the Node RPC API using tonic.
///
/// If the `tonic` feature is enabled, this client will use a `tonic::transport::Channel` to
/// communicate with the node. In this case the connection will be established lazily when the
/// first request is made.
/// If the `web-tonic` feature is enabled, this client will use a `tonic_web_wasm_client::Client`
/// to communicate with the node.
///
/// In both cases, the [`TonicRpcClient`] depends on the types inside the `generated` module, which
/// are generated by the build script and also depend on the target architecture.
pub struct TonicRpcClient {
    client: RwLock<Option<ApiClient>>,
    endpoint: String,
    timeout_ms: u64,
    genesis_commitment: RwLock<Option<Word>>,
}

impl TonicRpcClient {
    /// Returns a new instance of [`TonicRpcClient`] that'll do calls to the provided [`Endpoint`]
    /// with the given timeout in milliseconds.
    pub fn new(endpoint: &Endpoint, timeout_ms: u64) -> TonicRpcClient {
        TonicRpcClient {
            client: RwLock::new(None),
            endpoint: endpoint.to_string(),
            timeout_ms,
            genesis_commitment: RwLock::new(None),
        }
    }

    /// Takes care of establishing the RPC connection if not connected yet. It ensures that the
    /// `rpc_api` field is initialized and returns a write guard to it.
    async fn ensure_connected(&self) -> Result<ApiClient, RpcError> {
        if self.client.read().is_none() {
            self.connect().await?;
        }

        Ok(self.client.read().as_ref().expect("rpc_api should be initialized").clone())
    }

    /// Connects to the Miden node, setting the client API with the provided URL, timeout and
    /// genesis commitment.
    async fn connect(&self) -> Result<(), RpcError> {
        let genesis_commitment = *self.genesis_commitment.read();
        let new_client =
            ApiClient::new_client(self.endpoint.clone(), self.timeout_ms, genesis_commitment)
                .await?;
        let mut client = self.client.write();
        client.replace(new_client);

        Ok(())
    }
}

#[cfg_attr(not(target_arch = "wasm32"), async_trait::async_trait)]
#[cfg_attr(target_arch = "wasm32", async_trait::async_trait(?Send))]
impl NodeRpcClient for TonicRpcClient {
    /// Sets the genesis commitment for the client. If the client is already connected, it will be
    /// updated to use the new commitment on subsequent requests. If the client is not connected,
    /// the commitment will be used when it connects. If the genesis commitment is already set,
    /// this method does nothing.
    async fn set_genesis_commitment(&self, commitment: Word) -> Result<(), RpcError> {
        self.ensure_connected().await?;

        if self.genesis_commitment.read().is_some() {
            // Genesis commitment is already set, ignoring the new value.
            return Ok(());
        }

        self.genesis_commitment.write().replace(commitment);

        // If a client is connected, we modify it to use the new genesis commitment.
        let mut client_guard = self.client.write();
        if let Some(client) = client_guard.as_mut() {
            client.set_genesis_commitment(commitment);
        }

        Ok(())
    }

    async fn submit_proven_transaction(
        &self,
        proven_transaction: ProvenTransaction,
    ) -> Result<BlockNumber, RpcError> {
        let request = proto::transaction::ProvenTransaction {
            transaction: proven_transaction.to_bytes(),
        };

        let mut rpc_api = self.ensure_connected().await?;

        let api_response = rpc_api.submit_proven_transaction(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::SubmitProvenTx, status)
        })?;

        Ok(BlockNumber::from(api_response.into_inner().block_height))
    }

    async fn get_block_header_by_number(
        &self,
        block_num: Option<BlockNumber>,
        include_mmr_proof: bool,
    ) -> Result<(BlockHeader, Option<MmrProof>), RpcError> {
        let request = proto::shared::BlockHeaderByNumberRequest {
            block_num: block_num.as_ref().map(BlockNumber::as_u32),
            include_mmr_proof: Some(include_mmr_proof),
        };

        info!("Calling GetBlockHeaderByNumber: {:?}", request);

        let mut rpc_api = self.ensure_connected().await?;

        let api_response = rpc_api.get_block_header_by_number(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::GetBlockHeaderByNumber, status)
        })?;

        let response = api_response.into_inner();

        let block_header: BlockHeader = response
            .block_header
            .ok_or(RpcError::ExpectedDataMissing("BlockHeader".into()))?
            .try_into()?;

        let mmr_proof = if include_mmr_proof {
            let forest = response
                .chain_length
                .ok_or(RpcError::ExpectedDataMissing("ChainLength".into()))?;
            let merkle_path: MerklePath = response
                .mmr_path
                .ok_or(RpcError::ExpectedDataMissing("MmrPath".into()))?
                .try_into()?;

            Some(MmrProof {
                forest: Forest::new(usize::try_from(forest).expect("u64 should fit in usize")),
                position: block_header.block_num().as_usize(),
                merkle_path,
            })
        } else {
            None
        };

        Ok((block_header, mmr_proof))
    }

    async fn get_notes_by_id(&self, note_ids: &[NoteId]) -> Result<Vec<FetchedNote>, RpcError> {
        let request = proto::note::NoteIdList {
            ids: note_ids.iter().map(|id| (*id).into()).collect(),
        };

        let mut rpc_api = self.ensure_connected().await?;

        let api_response = rpc_api.get_notes_by_id(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::GetNotesById, status)
        })?;

        let response_notes = api_response
            .into_inner()
            .notes
            .into_iter()
            .map(FetchedNote::try_from)
            .collect::<Result<Vec<FetchedNote>, RpcConversionError>>()?;

        Ok(response_notes)
    }

    /// Sends a sync state request to the Miden node, validates and converts the response
    /// into a [`StateSyncInfo`] struct.
    async fn sync_state(
        &self,
        block_num: BlockNumber,
        account_ids: &[AccountId],
        note_tags: &BTreeSet<NoteTag>,
    ) -> Result<StateSyncInfo, RpcError> {
        let account_ids = account_ids.iter().map(|acc| (*acc).into()).collect();

        let note_tags = note_tags.iter().map(|&note_tag| note_tag.into()).collect();

        let request = proto::rpc_store::SyncStateRequest {
            block_num: block_num.as_u32(),
            account_ids,
            note_tags,
        };

        let mut rpc_api = self.ensure_connected().await?;

        let response = rpc_api.sync_state(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::SyncState, status)
        })?;
        response.into_inner().try_into()
    }

    /// Sends a `GetAccountDetailsRequest` to the Miden node, and extracts an [`FetchedAccount`]
    /// from the `GetAccountDetailsResponse` response.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    ///
    /// - There was an error sending the request to the node.
    /// - The answer had a `None` for one of the expected fields (`account`, `summary`,
    ///   `account_commitment`, `details`).
    /// - There is an error during [Account] deserialization.
    async fn get_account_details(&self, account_id: AccountId) -> Result<FetchedAccount, RpcError> {
        let request = proto::account::AccountId { id: account_id.to_bytes() };

        let mut rpc_api = self.ensure_connected().await?;

        let response = rpc_api.get_account_details(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::GetAccountDetails, status)
        })?;
        let response = response.into_inner();
        let account_summary = response.summary.ok_or(RpcError::ExpectedDataMissing(
            "GetAccountDetails response should have an `summary`".to_string(),
        ))?;

        let commitment =
            account_summary.account_commitment.ok_or(RpcError::ExpectedDataMissing(
                "GetAccountDetails response's account should have an `account_commitment`"
                    .to_string(),
            ))?;

        let commitment = commitment.try_into()?;

        let update_summary = AccountUpdateSummary::new(commitment, account_summary.block_num);
        if account_id.is_private() {
            Ok(FetchedAccount::Private(account_id, update_summary))
        } else {
            let account = Account::read_from_bytes(&response.details.ok_or(
                RpcError::ExpectedDataMissing(
                    "GetAccountDetails response should have an `account`".to_string(),
                ),
            )?)?;

            Ok(FetchedAccount::Public(account, update_summary))
        }
    }

    /// Sends a `GetAccountProofs` request to the Miden node, and extracts a list of [AccountProof]
    /// from the response, as well as the block number that they were retrieved for.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    ///
    /// - One of the requested Accounts isn't returned by the node.
    /// - There was an error sending the request to the node.
    /// - The answer had a `None` for one of the expected fields.
    /// - There is an error during storage deserialization.
    async fn get_account_proofs(
        &self,
        account_requests: &BTreeSet<ForeignAccount>,
        known_account_codes: BTreeMap<AccountId, AccountCode>,
    ) -> Result<AccountProofs, RpcError> {
        if account_requests.is_empty() {
            let (header, _) = self.get_block_header_by_number(None, false).await?;
            return Ok((header.block_num(), Vec::new()));
        }

        let known_codes_by_commitment: BTreeMap<Word, AccountCode> =
            known_account_codes.values().cloned().map(|c| (c.commitment(), c)).collect();

        let mut rpc_api = self.ensure_connected().await?;

        let mut block_num: Option<BlockNumber> = None;
        let mut account_proofs = Vec::with_capacity(account_requests.len());

        // Request proofs one-by-one using the singular API
        for foreign_account in account_requests {
            let account_id = foreign_account.account_id();

            // Only request details for public accounts; include known code commitment for this
            // account when available
            let account_details = if account_id.is_public() {
                let code_commitment = known_account_codes
                    .get(&account_id)
                    .map(|code| proto::primitives::Digest::from(code.commitment()));
                Some(proto::rpc_store::account_proof_request::AccountDetailsRequest {
                    code_commitment,
                    storage_requests: foreign_account.storage_slot_requirements().into(),
                })
            } else {
                None
            };

            let request = proto::rpc_store::AccountProofRequest {
                account_id: Some(account_id.into()),
                account_details,
            };

            let response = rpc_api
                .get_account_proof(request)
                .await
                .map_err(|status| {
                    RpcError::from_grpc_error(NodeRpcClientEndpoint::GetAccountProofs, status)
                })?
                .into_inner();

            let this_block_num: BlockNumber = response.block_num.into();
            if block_num.is_none() {
                block_num = Some(this_block_num);
            }

            let account_witness: AccountWitness = response
                .witness
                .ok_or(RpcError::ExpectedDataMissing("AccountWitness".to_string()))?
                .try_into()?;

            // For public accounts, details should be present when requested
            let headers = if account_witness.id().is_public() {
                Some(
                    response
                        .details
                        .ok_or(RpcError::ExpectedDataMissing("Account.Details".to_string()))?
                        .into_domain(&known_codes_by_commitment)?,
                )
            } else {
                None
            };

            let proof = AccountProof::new(account_witness, headers)
                .map_err(|err| RpcError::InvalidResponse(err.to_string()))?;
            account_proofs.push(proof);
        }

        Ok((block_num.expect("at least one request present"), account_proofs))
    }

    /// Sends a `SyncNoteRequest` to the Miden node, and extracts a [`NoteSyncInfo`] from the
    /// response.
    async fn sync_notes(
        &self,
        block_num: BlockNumber,
        note_tags: &BTreeSet<NoteTag>,
    ) -> Result<NoteSyncInfo, RpcError> {
        let note_tags = note_tags.iter().map(|&note_tag| note_tag.into()).collect();

        let request =
            proto::rpc_store::SyncNotesRequest { block_num: block_num.as_u32(), note_tags };

        let mut rpc_api = self.ensure_connected().await?;

        let response = rpc_api.sync_notes(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::SyncNotes, status)
        })?;

        response.into_inner().try_into()
    }

    async fn sync_nullifiers(
        &self,
        prefixes: &[u16],
        block_num: BlockNumber,
        block_to: Option<BlockNumber>,
    ) -> Result<Vec<NullifierUpdate>, RpcError> {
        const MAX_ITERATIONS: u32 = 1000; // Safety limit to prevent infinite loops

        let mut all_nullifiers = Vec::new();
        let mut seen_nullifiers = BTreeSet::new();
        let mut current_block_from = block_num.as_u32();

        // Establish RPC connection once before the loop
        let mut rpc_api = self.ensure_connected().await?;

        for _ in 0..MAX_ITERATIONS {
            let request = proto::rpc_store::SyncNullifiersRequest {
                nullifiers: prefixes.iter().map(|&x| u32::from(x)).collect(),
                prefix_len: 16,
                block_range: Some(BlockRange {
                    block_from: current_block_from,
                    block_to: block_to.map(|b| b.as_u32()),
                }),
            };

            let response = rpc_api.sync_nullifiers(request).await.map_err(|status| {
                RpcError::from_grpc_error(NodeRpcClientEndpoint::SyncNullifiers, status)
            })?;
            let response = response.into_inner();

            // Convert nullifiers for this batch
            let batch_nullifiers = response
                .nullifiers
                .iter()
                .map(TryFrom::try_from)
                .collect::<Result<Vec<NullifierUpdate>, _>>()
                .map_err(|err| RpcError::InvalidResponse(err.to_string()))?;

            // Check for duplicates and add to results
            for nullifier_update in batch_nullifiers {
                if !seen_nullifiers.insert(nullifier_update.nullifier) {
                    return Err(RpcError::InvalidResponse(
                        "duplicate nullifier found in response".to_string(),
                    ));
                }
                all_nullifiers.push(nullifier_update);
            }

            // Check if we need to fetch more pages
            if let Some(page) = response.pagination_info {
                // Ensure we're making progress to avoid infinite loops
                if page.block_num < current_block_from {
                    return Err(RpcError::InvalidResponse(
                        "invalid pagination: block_num went backwards".to_string(),
                    ));
                }

                // Calculate target block as minimum between block_to and chain_tip
                let target_block =
                    block_to.map_or(page.chain_tip, |b| b.as_u32().min(page.chain_tip));

                if page.block_num < target_block {
                    current_block_from = page.block_num + 1;
                    continue;
                }
            }
            // No pagination info or we've reached/passed the target so we're done
            return Ok(all_nullifiers);
        }

        // If we exit the loop, we've hit the iteration limit
        Err(RpcError::InvalidResponse(
            "too many pagination iterations, possible infinite loop".to_string(),
        ))
    }

    async fn check_nullifiers(&self, nullifiers: &[Nullifier]) -> Result<Vec<SmtProof>, RpcError> {
        let request = proto::rpc_store::NullifierList {
            nullifiers: nullifiers.iter().map(|nul| nul.as_word().into()).collect(),
        };

        let mut rpc_api = self.ensure_connected().await?;

        let response = rpc_api.check_nullifiers(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::CheckNullifiers, status)
        })?;

        let response = response.into_inner();
        let proofs = response.proofs.iter().map(TryInto::try_into).collect::<Result<_, _>>()?;

        Ok(proofs)
    }

    async fn get_block_by_number(&self, block_num: BlockNumber) -> Result<ProvenBlock, RpcError> {
        let request = proto::blockchain::BlockNumber { block_num: block_num.as_u32() };

        let mut rpc_api = self.ensure_connected().await?;

        let response = rpc_api.get_block_by_number(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::GetBlockByNumber, status)
        })?;

        let response = response.into_inner();
        let block =
            ProvenBlock::read_from_bytes(&response.block.ok_or(RpcError::ExpectedDataMissing(
                "GetBlockByNumberResponse.block".to_string(),
            ))?)?;

        Ok(block)
    }

    async fn get_note_script_by_root(&self, root: Word) -> Result<NoteScript, RpcError> {
        let request = proto::note::NoteRoot { root: Some(root.into()) };

        let mut rpc_api = self.ensure_connected().await?;

        let response = rpc_api.get_note_script_by_root(request).await.map_err(|status| {
            RpcError::from_grpc_error(NodeRpcClientEndpoint::GetNoteScriptByRoot, status)
        })?;

        let response = response.into_inner();
        let note_script = NoteScript::try_from(
            response
                .script
                .ok_or(RpcError::ExpectedDataMissing("GetNoteScriptByRoot.script".to_string()))?,
        )?;

        Ok(note_script)
    }
}

// ERRORS
// ================================================================================================

impl RpcError {
    pub fn from_grpc_error(endpoint: NodeRpcClientEndpoint, status: Status) -> Self {
        if let Some(accept_error) = AcceptHeaderError::try_from_message(status.message()) {
            return Self::AcceptHeaderError(accept_error);
        }

        let error_kind = GrpcError::from(&status);
        let source = Box::new(status) as Box<dyn Error + Send + Sync + 'static>;

        Self::GrpcError {
            endpoint,
            error_kind,
            source: Some(source),
        }
    }
}

impl From<&Status> for GrpcError {
    fn from(status: &Status) -> Self {
        GrpcError::from_code(status.code() as i32, Some(status.message().to_string()))
    }
}

#[cfg(test)]
mod tests {
    use std::boxed::Box;

    use miden_objects::Word;

    use super::TonicRpcClient;
    use crate::rpc::{Endpoint, NodeRpcClient};

    fn assert_send_sync<T: Send + Sync>() {}

    #[test]
    fn is_send_sync() {
        assert_send_sync::<TonicRpcClient>();
        assert_send_sync::<Box<dyn NodeRpcClient>>();
    }

    // Function that returns a `Send` future from a dynamic trait that must be `Sync`.
    async fn dyn_trait_send_fut(client: Box<dyn NodeRpcClient>) {
        // This won't compile if `get_block_header_by_number` doesn't return a `Send+Sync` future.
        let res = client.get_block_header_by_number(None, false).await;
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn future_is_send() {
        let endpoint = &Endpoint::devnet();
        let client = TonicRpcClient::new(endpoint, 10000);
        let client: Box<TonicRpcClient> = client.into();
        tokio::task::spawn(async move { dyn_trait_send_fut(client).await });
    }

    #[tokio::test]
    async fn set_genesis_commitment_sets_the_commitment_when_its_not_already_set() {
        let endpoint = &Endpoint::devnet();
        let client = TonicRpcClient::new(endpoint, 10000);

        assert!(client.genesis_commitment.read().is_none());

        let commitment = Word::default();
        client.set_genesis_commitment(commitment).await.unwrap();

        assert_eq!(client.genesis_commitment.read().unwrap(), commitment);
    }

    #[tokio::test]
    async fn set_genesis_commitment_does_nothing_if_the_commitment_is_already_set() {
        use miden_objects::Felt;

        let endpoint = &Endpoint::devnet();
        let client = TonicRpcClient::new(endpoint, 10000);

        let initial_commitment = Word::default();
        client.set_genesis_commitment(initial_commitment).await.unwrap();

        let new_commitment = Word::from([Felt::new(1), Felt::new(2), Felt::new(3), Felt::new(4)]);
        client.set_genesis_commitment(new_commitment).await.unwrap();

        assert_eq!(client.genesis_commitment.read().unwrap(), initial_commitment);
    }

    #[tokio::test]
    async fn set_genesis_commitment_updates_the_client_if_already_connected() {
        let endpoint = &Endpoint::devnet();
        let client = TonicRpcClient::new(endpoint, 10000);

        // "Connect" the client
        client.connect().await.unwrap();

        let commitment = Word::default();
        client.set_genesis_commitment(commitment).await.unwrap();

        assert_eq!(client.genesis_commitment.read().unwrap(), commitment);
        assert!(client.client.read().as_ref().is_some());
    }
}
